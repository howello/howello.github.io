---
layout: post
title: 设计模式
subtitle: 设计模式详解
date: 2024-10-30
author: Howe
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
   - 设计模式
   - 常用设计模式
   - 设计模式详解
---

# 设计模式（https://blog.csdn.net/lovelion/article/details/17517213）

## 1. 来源

### 1.1  Christopher Alexander（克里斯托弗.亚历山大）

1.1.1 模式之父

1.1.2 每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次地重用那些已有的成功的解决方案，无须再重复相同的工作。这个定义可以简单地用一句话表示：

> 模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。
>
> 【A pattern is a successful or efficient solution to a recurring  problem within a context】

![image-20220530114027635](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202205301140679.png)

### 1.2 常用设计模式



![image-20220530151419971](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202205301514060.png)

![image-20220530151437718](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202205301514794.png)

![image-20220530151453440](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202205301514493.png)

### 1.3 学前所知

作为设计模式的忠实粉丝和推广人员，在正式学习设计模式之前，我结合多年的模式应用和教育培训经验与大家分享几点个人的看法，以作参考：

```txt
   (1) 掌握设计模式并不是件很难的事情，关键在于多思考，多实践，不要听到人家说懂几个设计模式就很“牛”，只要用心学习，设计模式也就那么回事，你也可以很“牛”的，一定要有信心。

  (2) 在学习每一个设计模式时至少应该掌握如下几点：这个设计模式的意图是什么，它要解决一个什么问题，什么时候可以使用它；它是如何解决的，掌握它的结构图，记住它的关键代码；能够想到至少两个它的应用实例，一个生活中的，一个软件中的；这个模式的优缺点是什么，在使用时要注意什么。当你能够回答上述所有问题时，恭喜你，你了解一个设计模式了，至于掌握它，那就在开发中去使用吧，用多了你自然就掌握了。

  (3) “如果想体验一下运用模式的感觉，那么最好的方法就是运用它们”。正如在本章最开始所说的，设计模式是“内功心法”，它还是要与“实战招式”相结合才能够相得益彰。学习设计模式的目的在于应用，如果不懂如何使用一个设计模式，而只是学过，能够说出它的用途，绘制它的结构，充其量也只能说你了解这个模式，严格一点说：不会在开发中灵活运用一个模式基本上等于没学。所以一定要做到：少说多做。

  (4) 千万不要滥用模式，不要试图在一个系统中用上所有的模式，也许有这样的系统，但至少目前我没有碰到过。每个模式都有自己的适用场景，不能为了使用模式而使用模式？【怎么理解，大家自己思考，】，滥用模式不如不用模式，因为滥用的结果得不到“艺术品”一样的软件，很有可能是一堆垃圾代码。

  (5) 如果将设计模式比喻成“三十六计”，那么每一个模式都是一种计策，它为解决某一类问题而诞生，不管这个设计模式的难度如何，使用频率高不高，我建议大家都应该好好学学，多学一个模式也就意味着你多了“一计”，说不定什么时候一不小心就用上了，。因此，模式学习之路上要不怕困难，勇于挑战，有的模式虽然难一点，但反复琢磨，反复研读，应该还是能够征服的。

  (6) 设计模式的“上乘”境界：“手中无模式，心中有模式”。模式使用的最高境界是你已经不知道具体某个设计模式的定义和结构了，但你会灵活自如地选择一种设计方案【其实就是某个设计模式】来解决某个问题，设计模式已经成为你开发技能的一部分，能够手到擒来，“内功”与“招式”已浑然一体，要达到这个境界并不是看完某本书或者开发一两个项目就能够实现的，它需要不断沉淀与积累，所以，对模式的学习不要急于求成。

  (7) 最后一点来自GoF已故成员、我个人最尊敬和崇拜的软件工程大师之一John Vlissides的著作《设计模式沉思录》(Pattern Hatching Design Patterns Applied)：模式从不保证任何东西，它不能保证你一定能够做出可复用的软件，提高你的生产率，更不能保证世界和平，。模式并不能替代人来完成软件系统的创造，它们只不过会给那些缺乏经验但却具备才能和创造力的人带来希望。
```

## 2. 七大设计原则

### 2.1 如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一

![image-20220530154111051](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202205301541155.png)

### 2.2 单一职责原则

> **单一职责原则(Single Responsibility Principle, SRP)**：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。**

单一职责原则是实现**高内聚、低耦合**的指导方针，它是最简单但又最难运用的原则

### 2.3 开闭原则

> **开闭原则\**(Open-Closed Principle, OCP)\**：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。**

在开闭原则的定义中，**软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类**。

在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。如果一个系统在扩展时只涉及到修改配置文件，而原有的Java代码或C#代码没有做任何修改，该系统即可认为是一个符合开闭原则的系统。

### 2.4 里氏代换原则

> **里氏代换原则\**(Liskov Substitution Principle, LSP)\**：所有引用基类（父类）的地方必须能透明地使用其子类的对象。**

里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此**在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象**。

> 注意：
>
>   (1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。
>
>   (2)  我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。
>     
>   (3) Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。

### 2.5 依赖倒转原则

> **依赖倒转原则**(Dependency Inversion Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。

 在上述重构过程中，我们使用了开闭原则、里氏代换原则和依赖倒转原则，在大多数情况下，这三个设计原则会同时出现，**开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段**，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。

### 2.6 接口隔离原则

> **接口隔离原则** *(Interface Segregation Principle, ISP)*：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。

**在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。**一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。

### 2.7 合成复用原则

> **合成复用原则** *(Composite Reuse Principle, CRP)*：尽量使用对象组合，而不是继承来达到复用的目的。简言之：**复用时要尽量使用组合\**/\**聚合关系（关联关系），少用继承**。

### 2.8 迪米特法则

> **迪米特法则** *(Law of Demeter, LoD)* **：一个软件实体应当尽可能少地与其他实体发生相互作用。**
>
> 迪米特法则又称为最少知识原则(LeastKnowledge Principle, LKP)

在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；

在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；

在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。

## 3. 六个创建型模式

> 1. 简单工厂模式
> 2. 工厂方法模式
> 3. 抽象工厂方法
> 4. 单例模式
> 5. 原型模式
> 6. 建造者模式

### 3.1 简单工厂模式

>   简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为**静态工厂方法**(Static Factory Method)模式，它属于类创建型模式。



#### 3.1.1 在简单工厂模式结构图中包含如下几个角色：

- **Factor（工厂角色）：**工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。
- **Product（抽象产品角色）：**它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。
- **ConcreteProduct（具体产品角色）：**它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。

在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。

#### 3.1.2 代码实现

1. 抽象类 **Product**

```java
public abstract class Product {

    public void save(){
        System.out.println("抽象父类的保存方法");
    }

    public void delete(){
        System.out.println("抽象父类的删除方法");
    }

    public abstract void update();
}
```

2. 抽象类子类 **Book**

```java
public class Book extends Product {

    @Override
    public void save() {
        super.save();
        System.out.println("书籍的保存方法");
    }

    @Override
    public void update() {
        System.out.println("书籍的更新方法");
    }
}
```

3. 抽象类子类 **computer**

```java
public class Computer extends Product {
    @Override
    public void update() {
        System.out.println("电脑的更新方法");
    }

    @Override
    public void delete() {
        super.delete();
        System.out.println("电脑的删除方法");
    }
}
```

4. 工厂类 **Factory**

```java
public class Factory {

    public static Product getProduct(String type) {
        switch (type) {
            case "book":
                return new Book();
            case "computer":
                return new Computer();
            default:
                return null;
        }
    }
}
```

5. 测试代码

```java
public static void main(String[] args) {
    Product book = Factory.getProduct("computer");
    book.save();
    book.delete();
    book.update();
}
```

6. 测试结果

![image-20220531105358764](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202205311053908.png)

#### 3.1.3 总结

1. 就是简单的使用工厂的静态方法创建实现类。减少了耦合，如果需要增加或者减少产品类型的话，只需要动工厂类，实际的产品不需要修改。

2. 算是解决了一下痛点。比如不用每次都自己new，拓展代码的时候需要一个一个改。

3. 自认为的缺点，估计后续的设计模式会改变这几个：
   - 创建方法时还需要传这个参数，传的type是字符串，写代码时不是很友好
   - 工厂静态类创建实现类的时候，用了大量的条件选择（if...else或者switch...case），就不是很完美。

4. 适用场景
   - 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
   - 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。

### 3.2 工厂方法模式

> **工厂方法模式(Factory Method Pattern)**：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。
>
> 工厂方法模式让一个类的实例化延迟到其子类。
>
> 工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。
>
> 工厂方法模式是一种类创建型模式。

#### 3.2.1 在工厂方法模式结构图中包含如下几个角色：

- **Product（抽象产品）**：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。
  
- **ConcreteProduct（具体产品）**：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。
  
- **Factory（抽象工厂）**：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。
  
- **ConcreteFactory（具体工厂）**：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。

与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类，

#### 3.2.2 代码实现

1. 产品类

   ```java
   //Product父类
   public abstract class Product {
       public void save() {
           System.out.println("抽象父类的保存方法");
       }
   
       public void delete() {
           System.out.println("抽象父类的删除方法");
       }
   
       public abstract void update();
   }
   
   //产品书实现
   public class BookProduct extends Product {
       @Override
       public void update() {
           System.out.println("书籍更新");
       }
   }
   
   //产品电脑实现
   public class ComputerProduct extends Product {
       @Override
       public void update() {
           System.out.println("电脑更新");
       }
   }
   ```

2. 工厂类

   ```java
   //工厂父接口
   public interface Factory {
       public Product createProduct();
   }
   
   //产品书的工厂实现
   public class BookFactory implements Factory {
       @Override
       public Product createProduct() {
           return new BookProduct();
       }
   }
   
   //产品电脑的工厂实现
   public class ComputerFactory implements Factory {
       @Override
       public Product createProduct() {
           return new ComputerProduct();
       }
   }
   ```

3. 测试类

   ```java
   public class Main {
       public static void main(String[] args) {
           Factory factory = new BookFactory();
           factory.createProduct().update();
   
           factory = new ComputerFactory();
           factory.createProduct().update();
       }
   }
   ```

4. 测试结果

![image-20220531105450751](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202205311054925.png)

#### 3.2.3 总结

1. 完美解决了简单工厂模式需要传type来进行定位的不好之处。
2. 解决了简单工厂模式中，工厂需要大量条件语句的弊端。
3. 增加新产品时，只需要增加产品实现类，继承产品父类即可。然后增加产品工厂实现类，实现工厂接口即可。不需要进行代码的修改。
4. 自认为的缺点
   - 虽然解决了增加产品时的问题。但是加一个产品就得加一个工厂，这块是不是能更加优化一下。（或许时理解的不太全）

#### 3.2.4 优化

1. 工厂重载

   可以在工厂中添加不同入参的方法来进一步进行工厂的多样话配置，比如某个工厂需要数据库连接，某个不需要，但需要线程池配置等。

   - 工厂可修改为这样

   ```java
   //工厂接口
   public interface Factory {
       public Product createProduct();
   
       public Product createProduct(String... args);
   
       public Product createProduct(ProductSettings settings);
   }
   
   //书籍实现工厂
   public class BookFactory implements Factory {
       @Override
       public Product createProduct() {
           return new BookProduct();
       }
   
       @Override
       public Product createProduct(String... args) {
           //此处可以根据args的值来配置不同的产品。比如数据库连接、线程池等。
           //代码省略
           return new BookProduct();
       }
   
       @Override
       public Product createProduct(ProductSettings settings) {
           //此处可以根据配置对象来配置不同的产品。比如数据库连接、线程池等。
           //代码省略
           return new BookProduct();
       }
   }
   
   //电脑实现工厂
   public class ComputerFactory implements Factory {
       @Override
       public Product createProduct() {
           return new ComputerProduct();
       }
   
       @Override
       public Product createProduct(String... args) {
           //此处可以根据args的值来配置不同的产品。比如数据库连接、线程池等。
           //代码省略
           return new ComputerProduct();
       }
   
       @Override
       public Product createProduct(ProductSettings settings) {
           //此处可以根据配置对象来配置不同的产品。比如数据库连接、线程池等。
           //代码省略
           return new ComputerProduct();
       }
   }
   ```

   在抽象工厂中定义多个重载的工厂方法，在具体工厂中实现了这些工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同产品对象的需求。

   > 思考：这里可以在工厂接口类里面添加默认方法default（java8），子类也不一定需要实现，需要才实现。能更进一步根据多样性配置不用的工厂。

2. 工厂方法隐藏（隐藏产品应该更贴切）

可以在工厂里面直接调用产品的方法，这样用户就不用管产品类是什么情况，只需要实例化工厂，然后调用工厂方法就可以。

代码：

```java
//工厂接口
public interface Factory {
    public Product createProduct();

    public Product createProduct(String... args);

    public Product createProduct(ProductSettings settings);

    default void save() {
        Product product = this.createProduct();
        product.save();
    }
}

//测试类
public static void main(String[] args) {
    Factory factory = new BookFactory();
    factory.save();
}

//其他代码略
```

> 思考：进一步将用户调用简化了。使用默认方法，增加的时候也可以选择是否重写。

#### 3.2.5 适用场景

 (1) 客户端不知道它所需要的对象的类。

在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。

(2) 抽象工厂类通过其子类来指定创建哪个对象。

在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。

### 3.3 抽象工厂模式

>   **抽象工厂模式(Abstract Factory Pattern)**：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为**Kit**模式，它是一种对象创建型模式。

#### 3.3.1 在抽象工厂模式结构图中包含如下几个角色：

- **AbstractFactory（抽象工厂）**：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。
  
- **ConcreteFactory（具体工厂）**：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。
  
- **AbstractProduct（抽象产品）**：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。
  
- **ConcreteProduct（具体产品）**：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。

#### 3.3.2 代码实现

> 结合现实生活其实很好理解。比如说现在造东西的有很多厂，比如苹果、联想、dell。每个厂他不光造一样的东西。
>
> 这里我们把他们造的一样的东西拿出来几样做例子。比如，都会造书、造电脑。

##### 3.3.2.1 实现抽象工厂

1. 首先，这里我们的产品就是两样：书、电脑。那么就可以先建一个接口`Book`及`Computer`

```java
//书
public interface Book {
    public void save();
}

//电脑
public interface Computer {
    public void update();
}
```

2. 然后，这两样东西的实现，是谁造出来的呢？三个厂家造的，分别进行实现

```java
//苹果造书
public class AppleBook implements Book {
    @Override
    public void save() {
        System.out.println("AppleBook save");
    }
}

//苹果造电脑
public class AppleComputer implements Computer {

    @Override
    public void update() {
        System.out.println("AppleComputer update");
    }
}

//dell造书
public class DellBook implements Book {
    @Override
    public void save() {
        System.out.println("DellBook save");
    }
}

//dell造电脑
public class DellComputer implements Computer {
    @Override
    public void update() {
        System.out.println("DellComputer update");
    }
}

//联想造书
public class LenovoBook implements Book {
    @Override
    public void save() {
        System.out.println("LenovoBook save");
    }
}

//联想造电脑
public class LenovoComputer implements Computer {
    @Override
    public void update() {
        System.out.println("LenovoComputer update");
    }
}
```

3. 到了这里，我们想。如果需要去调用的话，造一个东西只能实例一个，显然不太好。带入工厂思想。每个厂家创建一个工厂。

   然后这些工厂又有着相同的产品，分别为造书、造电脑。那就能提取为一个接口

   每个不同的厂家去实现不同的产品线

```java
//抽象工厂，不管怎么造的。只知道造这两样东西
public interface AbsFactory {

    public Book createBook();

    public Computer createComputer();
}

//苹果厂
public class AppleFactory implements AbsFactory {
    @Override
    public Book createBook() {
        return new AppleBook();
    }

    @Override
    public Computer createComputer() {
        return new AppleComputer();
    }
}

//Dell厂
public class DellFactory implements AbsFactory{
    @Override
    public Book createBook() {
        return new DellBook();
    }

    @Override
    public Computer createComputer() {
        return new DellComputer();
    }
}

//联想厂
public class LenovoFactory implements AbsFactory{
    @Override
    public Book createBook() {
        return new LenovoBook();
    }

    @Override
    public Computer createComputer() {
        return new LenovoComputer();
    }
}
```

4. 测试

```java
public static void main(String[] args) {
    AbsFactory factory = new DellFactory();
    factory.createComputer().update();
    factory.createBook().save();

    factory = new AppleFactory();
    factory.createBook().save();
    factory.createComputer().update();

    factory = new LenovoFactory();
    factory.createComputer().update();
    factory.createBook().save();
}
```

![image-20220531155559461](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202205311555599.png)

##### 3.3.2.2 添加一个工厂

这时候小米公司说，我也要造这些东西。把我也加进去。

1. 首先我们添加小米的工厂

```java
public class MiFactory implements AbsFactory{
    @Override
    public Book createBook() {
        return new MiBook();
    }

    @Override
    public Computer createComputer() {
        return new MiComputer();
    }
}
```

2. 我们添加小米的产品线

```java
//小米造书
public class MiBook implements Book {
    @Override
    public void save() {
        System.out.println("MiBook save");
    }
}

//小米造电脑
public class MiComputer implements Computer {
    @Override
    public void update() {
        System.out.println("MiComputer update");
    }
}
```

3. 测试

```java
public static void main(String[] args) {
    AbsFactory factory = new MiFactory();
    factory.createBook().save();
    factory.createComputer().update();
}
```

![image-20220531160042668](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202205311600780.png)

4. 小结

我们发现，添加一个工厂是真的简单，只需要实现产品线，实现工厂类就可以了。完全不会动原有的代码。符合**开闭原则**

##### 3.3.2.3 添加一个产品

新能源车活了。所有厂家赶紧入行开始造车，需要添加产品线，造车。

1. 添加车的产品

```java
public interface Car {
    public void drive();
}
```

2. 四个厂分别实现造车流水线

```java
public class AppleCar implements Car {
    @Override
    public void drive() {
        System.out.println("AppleCar drive");
    }
}

//dell
public class DellCar implements Car {
    @Override
    public void drive() {
        System.out.println("DellCar drive");
    }
}

public class LenovoCar implements Car {
    @Override
    public void drive() {
        System.out.println("LenovoCar drive");
    }
}

public class MiCar implements Car {

    @Override
    public void drive() {
        System.out.println("MiCar drive");
    }
}
```

3. 修改抽象工厂，添加造车流水线。每个厂分别实现

```java
public interface AbsFactory {
    
	...
    
    public Car createCar();
}

public class AppleFactory implements AbsFactory {
    ...

    @Override
    public Car createCar() {
        return new AppleCar();
    }
}

public class DellFactory implements AbsFactory{
    ...

    @Override
    public Car createCar() {
        return new DellCar();
    }
}

public class LenovoFactory implements AbsFactory{
    ...

    @Override
    public Car createCar() {
        return new LenovoCar();
    }
}

public class MiFactory implements AbsFactory{
    ...

    @Override
    public Car createCar() {
        return new MiCar();
    }
}
```

4. 测试

```java
public static void main(String[] args) {
    AbsFactory factory = new DellFactory();
    factory.createComputer().update();
    factory.createBook().save();
    factory.createCar().drive();
    factory = new AppleFactory();
    factory.createBook().save();
    factory.createComputer().update();
    factory.createCar().drive();
    factory = new LenovoFactory();
    factory.createComputer().update();
    factory.createBook().save();
    factory.createCar().drive();
    factory = new MiFactory();
    factory.createCar().drive();
    factory.createBook().save();
    factory.createComputer().update();
}
```

![image-20220531160828978](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202205311608171.png)

5. 小结

可以看出，如果是添加一个产品的话，需要修改原有代码，而且改的很多。不符合开闭原则。

#### 3.3.3 总结

1. **在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦**，抽象工厂模式的这种性质称为**“开闭原则”的倾斜性**。
1. 优点：

- 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。
- 当一个产品线中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。
- 增加新的产品线很方便，无须修改已有系统，符合“开闭原则”。

3. 缺点

- 增加新的产品麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。

- 虽说添加麻烦，但是只要前期设计的时候考虑全面，添加产品线会更方便

#### 3.3.4 适用场景

- 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。
- 系统中有多于一个的产品线，而每次只使用其中某一产品线。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品线。
- 属于同一个产品线的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品线中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。
- **产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。**

### 3.4 单例模式

> **单例模式(Singleton Pattern)**：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。

#### 3.4.1 单例模式三要素

- 只能有一个实例
- 必须自行创建这个实例
- 必须自行向整个系统提供这个实例

#### 3.4.2 饿汉式单例类

饿汉式就是不管有没有，这个类在被加载的时候就会创建实例。用静态变量定义时就直接进行了类的实例化。然后构造方法定义为`private` 确保外部不能直接进行实例化。

```java
public class EagerSingleton {
    private static final EagerSingleton eagerSingleton = new EagerSingleton();

    private EagerSingleton() {
    }

    public static EagerSingleton getInstance(){
        return eagerSingleton;
    }

    public void doSomething(){
        System.out.println("do something");
    }
}
```

> 这是最简单的单例。但是由于时加载时就创建，消耗的资源比较多。

#### 3.4.3 懒汉式单例类

懒汉式是为了解决饿汉的问题，在需要的时候再进行实例化。

```java
public class LazySingleton {
    private static LazySingleton lazySingleton;

    private LazySingleton() {

    }

    public static LazySingleton getInstance() {
        if (lazySingleton == null) {
            lazySingleton = new LazySingleton();
        }
        return lazySingleton;
    }

    public void doSomething() {
        System.out.println("do something");
    }
}
```

> 懒汉虽然解决了饿汉消耗资源的问题，但是并发情况下，我们就会发现当两个线程同时进来的时候，会创建多个单例，违反了唯一性。

#### 3.4.4 单锁懒汉式单例类

为了解决并发情况不唯一的问题。给这个类加锁同步，确保唯一性。

```java
public class LazySingleton {
    private static LazySingleton lazySingleton;

    private LazySingleton() {

    }

    public static LazySingleton getInstance() {
        if (lazySingleton == null) {
            synchronized (LazySingleton.class){
                lazySingleton = new LazySingleton();
            }
        }
        return lazySingleton;
    }

    public void doSomething() {
        System.out.println("do something");
    }
}
```

> 虽然加锁同步了，但是还是会出现多个实例。
>
> 当线程A和B同时进入，都判断为null。这时A先进入同步块，B排队等候。A创建了一个实例Ai，出了同步块，然后B进入同步块，这时B不知道A已经创建了实例，B也是会创建一个实例Bi。
>
> 这时单例的唯一性被破坏。

#### 3.4.5 双检锁单例模式

进一步确保唯一性，可以在同步块内部再判断一下是否为空。申明静态变量时再加上 `volatile` 进一步确保了唯一性。

> Java的volatile关键字能保证变量修改后，对各个线程是可见的。也就是说加了这个关键字，不管你是从哪个线程读取都是同样的。
>
> **什么时候多线程读取不一致？**
>
> 多个cpu多个线程时，每个线程都有可能拷贝这个变量到自己对应的cpu里面。这样就会出现一个线程改变了，另一个线程拷贝的是改变前的变量。导致了线程之间不同步。

```java
public class DCLSingleton {
    private static volatile DCLSingleton dclSingleton;

    private DCLSingleton(){

    }

    public static DCLSingleton getInstance(){
        if (dclSingleton == null) {
            synchronized (DCLSingleton.class){
                if (dclSingleton == null) {
                    dclSingleton = new DCLSingleton();
                }
            }
        }
        return dclSingleton;
    }
    
    public void doSomething(){
        System.out.println("do something");
    }
}
```

> 到了这里，双检锁基本上可以搞定99%的单例情况了。几乎是完美的单例了，但是还存在以下两点问题。
>
> - 但是由于使用了 `volatile` 关键字，屏蔽了Java虚拟机所做的一些代码优化，可能会导致系统运行效率降低。
> - 如果遇到反射调用的时候，因为反射可以调用内部 `private` 方法，所以能够直接创建实例，就不能保证唯一性了。

#### 3.4.6 静态内部类单例模式（**IoDH**）

既然饿汉和懒汉都有缺点，那就自然有了客服这两个缺点的方法。在单例里面添加一个静态内部类。

```java
public class IoDHSingleton {
    private IoDHSingleton(){

    }
    private static class InnerClass{
        private static final IoDHSingleton IO_DH_SINGLETON = new IoDHSingleton();
    }

    public static IoDHSingleton getInstance(){
        return InnerClass.IO_DH_SINGLETON;
    }

    public void doSomething(){
        System.out.println("do something");
    }
}
```

通过使用**IoDH**，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的**Java**语言单例模式实现方式

#### 3.4.7 枚举实现单例模式

![image-20220601142746774](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206011427392.png)

大佬都这么说了。最完美好吧。无懈可击，起码我想不到什么能干掉这个。简单、搞笑、优美。

```java
public enum EnumSingleton {
    /**
     * 实例
     */
    INSTANCE;

    public void doSomething(){
        System.out.println("do something");
    }
}
```

这里我们再进行序列化测试和反射测试

```java
public static void main(String[] args) {
    EnumSingleton instance = EnumSingleton.INSTANCE;
    byte[] serialize = SerializationUtils.serialize(instance);
    Object deserialize = SerializationUtils.deserialize(serialize);
    System.out.println("instance = " + instance);
    System.out.println("deserialize = " + deserialize);
    System.out.println(instance == deserialize);
    
    Constructor<EnumSingleton> constructor = EnumSingleton.class.getDeclaredConstructor();
    constructor.setAccessible(true);
    EnumSingleton reInstance = constructor.newInstance();
    System.out.println("instance = " + instance);
    System.out.println("reInstance = " + reInstance);
    System.out.println(instance == reInstance);
}
```

![image-20220601143744952](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206011437040.png)

结果显而易见，序列化通过，反射直接报错。

> 这里反射报错，看源码可以知道是源码做了限制，如果反射的是`Enum`的话，会直接抛异常。具体可以看一下大佬的讲解。
>
> https://cloud.tencent.com/developer/article/1497592

#### 3.4.8 总结

有个缺点：单例没有抽象层，拓展成问题。

- 一般情况下，不建议使用懒汉式，使用线程安全的饿汉式。
- 如果需要懒加载的话，使用IoDH方式。
- 如果有特殊需求，可以考虑使用双检索
- 当然，任何情况都推件使用枚举方式。有下面这三个优点，还要什么自行车。
  - 反射安全
  - 序列化/反序列化安全
  - **写法简单**

### 3.5 原型模式

> **原型模式(Prototype Pattern)**：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。
>
> ***需要注意的是通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象。***

#### 3.5.1 原型模式结构图中包含如下几个角色：

- **Prototype（抽象原型类）**：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。
- **ConcretePrototype（具体原型类）**：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。
- **Client（客户类）**：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。

#### 3.5.2 简单实现

```java
@Data
public class ObjA implements Cloneable{

    private String name;

    //自定义
    public ObjA clone(){
        ObjA objA = new ObjA();
        objA.setName(this.name);
        return objA;
    }

    //通过Object的clone方法实现
    @SneakyThrows
    public ObjA clone2(){
       return (ObjA) super.clone();
    }
}

//测试
public static void main(String[] args) {
    ObjA objA = new ObjA();
    objA.setName("张三");
    ObjA clone1 = objA.clone();
    ObjA clone2 = objA.clone2();
    System.out.println("objA = " + objA);
    System.out.println("cloneA = " + clone1);
    System.out.println("clone2 = " + clone2);
    System.out.println("ObjA与clone1对比：" + (objA == clone1));
    System.out.println("ObjA与clone2对比：" + (objA == clone2));
}
```

![image-20220606100600698](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206061006033.png)

#### 3.5.3 深浅克隆

> 在Java语言中，数据类型分为**值类型**（基本数据类型）和**引用类型**
>
> 值类型:`int`、`double`、`byte`、`boolean`、`char`等简单数据类型
>
> 引用类型:`类`、`接口`、`数组`等复杂类型。
>
> **浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制**

##### 3.5.3.1 浅克隆

在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；

如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。

简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制

通过覆盖Object类的clone()方法可以实现浅克隆

```java
@Data
public class ShallowClone implements Cloneable {

    private String name;
    private Attachment attachment;

    @SneakyThrows
    public ShallowClone clone(){
        return (ShallowClone) super.clone();
    }
}

@Data
public class Attachment {
    private String name;
    private String url;

    public void download() {
        System.out.println("下载附件 = " + name + url);
    }
}

//测试
public static void main(String[] args) {
    ShallowClone shallowClone = new ShallowClone();
    shallowClone.setName("张三");
    Attachment attachment = new Attachment();
    attachment.setName("附件1");
    attachment.setUrl("http://www.baidu.com");
    shallowClone.setAttachment(attachment);
    ShallowClone clone = shallowClone.clone();
    System.out.println("shallowClone = " + shallowClone);
    System.out.println("clone = " + clone);
    System.out.println("shallowClone与clone对比：" + (shallowClone == clone));
    System.out.println("shallowClone的附件与clone的附件对比：" + (shallowClone.getAttachment() == clone.getAttachment()));
}
```

![image-20220606101602868](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206061016052.png)

可见，浅克隆的对象里面的对象在内存中是同一个。

##### 3.5.3.2 深克隆

在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。

简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制

在JAVA中，一般有两个简单方法来实现深拷贝。序列化（Serializable）和 JSON序列化

```java
@Data
public class DeepClone implements Serializable {
    private String name;

    private Attachment attachment;

    //通过序列化进行深拷贝
    public DeepClone cloneBySerializable() {
        try {
        	//将对象写入流
            ByteOutputStream byteOutputStream = new ByteOutputStream();
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteOutputStream);
            objectOutputStream.writeObject(this);
            //将对象读出流
            ByteArrayInputStream byteInputStream = new ByteArrayInputStream(byteOutputStream.getBytes());
            ObjectInputStream objectInputStream = new ObjectInputStream(byteInputStream);
            DeepClone deepClone = (DeepClone) objectInputStream.readObject();
            return deepClone;
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
            throw new RuntimeException("克隆失败");
        }
    }

    //通过Json进行深拷贝
    public DeepClone cloneByJson(){
        String jsonString = JSONObject.toJSONString(this);
        return JSONObject.parseObject(jsonString, DeepClone.class);
    }
}

@Data
public class Attachment implements Serializable {
    private String name;
    private String url;

    public void download() {
        System.out.println("下载附件 = " + name + url);
    }
}
```

测试：

```java
public static void main(String[] args) {
    DeepClone deepClone = new DeepClone();
    deepClone.setName("李四");
    Attachment attachment = new Attachment();
    attachment.setName("附件二：");
    attachment.setUrl("http://123.com");
    deepClone.setAttachment(attachment);
    DeepClone deepCloneBySe = deepClone.cloneBySerializable();
    DeepClone deepCloneByJson = deepClone.cloneByJson();
    System.out.println("deepClone = " + deepClone);
    System.out.println("deepCloneBySe = " + deepCloneBySe);
    System.out.println("deepCloneByJson = " + deepCloneByJson);
    System.out.println("deepClone与deepCloneBySe对比：" + (deepClone == deepCloneBySe));
    System.out.println("deepClone的附件与deepCloneBySe的附件对比：" + (deepClone.getAttachment() == deepCloneBySe.getAttachment()));
    System.out.println("deepClone与deepdeepCloneByJson对比：" + (deepClone == deepCloneByJson));
    System.out.println("deepClone的附件与deepCloneByJson的附件对比：" + (deepClone.getAttachment() == deepCloneByJson.getAttachment()));
}
```

![image-20220606104328115](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206061043479.png)

从结果可以看出，深拷贝之后，即使是引用类型也在内存中拷贝了一份，内存地址不用。

#### 3.5.4 原型管理器(Prototype Manager)

> **原型管理器(Prototype Manager)**是将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。
>
> 在原型管理器中针对抽象原型类进行编程，以便扩展。

```java
//模板接口
public interface IOfficeMoBan{
    public void print();

    //使用默认方法定义克隆方法
    default IOfficeMoBan cloneByJson(Class<?> clazz){
        String jsonString = JSONObject.toJSONString(this);
        return  (IOfficeMoBan) JSONObject.parseObject(jsonString, clazz);
    }
}

//接口实现
public class RegisterOffice implements IOfficeMoBan {
    @Override
    public void print() {
        System.out.println("打印登记处");
    }
}
public class RedcOffice implements IOfficeMoBan {
    @Override
    public void print() {
        System.out.println("减员打印");
    }
}

//原型管理器
//使用enum方法实现单例
public enum PrototypeManager {
    /**
     * 实例
     */
    INSTANCE;

    private static final Map<String, IOfficeMoBan> MAP = new HashMap<>();

    public void addOffice(String key,IOfficeMoBan iOfficeMoBan){
        MAP.put(key,iOfficeMoBan);
    }

    public IOfficeMoBan getOffice(String key){
        IOfficeMoBan iOfficeMoBan = MAP.get(key);
        return iOfficeMoBan.cloneByJson(iOfficeMoBan.getClass());
    }
}
```

测试：

```java
public static void main(String[] args) {
    PrototypeManager pm = PrototypeManager.INSTANCE;
    pm.addOffice("reg",new RegisterOffice());
    pm.addOffice("redc",new RedcOffice());
    IOfficeMoBan reg1 = pm.getOffice("reg");
    IOfficeMoBan reg2 = pm.getOffice("reg");
    reg1.print();
    reg2.print();
    System.out.println(reg1 == reg2);
    IOfficeMoBan redc1 = pm.getOffice("redc");
    IOfficeMoBan redc2 = pm.getOffice("redc");
    redc1.print();
    redc2.print();
    System.out.println(redc1 == redc2);
}
```

![image-20220606112951359](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206061129453.png)

这样的话如果添加一个新的实现类，直接添加接可以。不用修改代码。

#### 3.5.5 优点

-  当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。
- 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。
- 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。
- 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。

#### 3.5.6 适用场景

(1) 创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。

(2) 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。

(3) 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。

> 说实话，这个具体在什么情况下能用到，还有点迷。不是很清晰。

### 3.6 建造者模式

> **建造者模式(Builder Pattern)**：又称为生成器模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
>
> 建造者模式是一种对象创建型模式。

#### 3.6.1 在建造者模式结构图中包含如下几个角色

- **Builder（抽象建造者）**：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。
- **ConcreteBuilder（具体建造者）**：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。
- **Product（产品角色）**：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。
- Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。

#### 3.6.2 实现

1. 对象

```java
@Data
public class Computer {
    private String cpu;
    private String mainBoard;
    private String hardDisk;
    private String memory;
    private String displayCard;
    private String power;
    private String mouse;
    private String keyboard;
}
```

2. 抽象Builder

```java
public abstract class ComputerBuilder {

    protected Computer computer = new Computer();

    public abstract ComputerBuilder buildCpu();

    public abstract ComputerBuilder buildMainBoard();

    public abstract ComputerBuilder buildHardDisk();

    public abstract ComputerBuilder buildMemory();

    public abstract ComputerBuilder buildDisplayCard();

    public abstract ComputerBuilder buildPower();

    public abstract ComputerBuilder buildMouse();

    public abstract ComputerBuilder buildKeyboard();

    public Computer build() {
        return computer;
    }
}
```

3. Builder实现类

```java
//dell
public class DellComputerBuilder extends ComputerBuilder {
    @Override
    public ComputerBuilder buildCpu() {
        this.computer.setCpu("i7");
        return this;
    }

    @Override
    public ComputerBuilder buildMainBoard() {
        this.computer.setMainBoard("aoc");
        return this;
    }

    @Override
    public ComputerBuilder buildHardDisk() {
        this.computer.setHardDisk("ssd");
        return this;
    }

    @Override
    public ComputerBuilder buildMemory() {
        this.computer.setMemory("16g");
        return this;
    }


    @Override
    public ComputerBuilder buildDisplayCard() {
        this.computer.setDisplayCard("3070Ti");
        return this;
    }

    @Override
    public ComputerBuilder buildPower() {
        this.computer.setPower("500w");
        return this;
    }

    @Override
    public ComputerBuilder buildMouse() {
        this.computer.setMouse("403");
        return this;
    }

    @Override
    public ComputerBuilder buildKeyboard() {
        this.computer.setKeyboard("75");
        return this;
    }
}

//apple
public class AppleComputerBuilder extends ComputerBuilder {
    @Override
    public ComputerBuilder buildCpu() {
        this.computer.setCpu("m1");
        return this;
    }

    @Override
    public ComputerBuilder buildMainBoard() {
        this.computer.setMainBoard("apple");
        return this;
    }

    @Override
    public ComputerBuilder buildHardDisk() {
        this.computer.setHardDisk("ssd");
        return this;
    }

    @Override
    public ComputerBuilder buildMemory() {
        this.computer.setMemory("16g");
        return this;
    }

    @Override
    public ComputerBuilder buildDisplayCard() {
        this.computer.setDisplayCard("3090Ti");
        return this;
    }

    @Override
    public ComputerBuilder buildPower() {
        this.computer.setPower("650W");
        return this;
    }

    @Override
    public ComputerBuilder buildMouse() {
        this.computer.setMouse("apple");
        return this;
    }

    @Override
    public ComputerBuilder buildKeyboard() {
        this.computer.setKeyboard("apple");
        return this;
    }
}

```

4. 测试

```java
public static void main(String[] args) {
    Computer dellComputer = new DellComputerBuilder()
            .buildCpu()
            .buildMainBoard()
            .buildDisplayCard()
            .buildMemory()
            .buildPower()
            .buildMouse()
            .buildKeyboard()
            .buildHardDisk()
            .build();
    System.out.println("dellComputer = " + dellComputer);
    Computer appleComputer = new AppleComputerBuilder()
            .buildCpu()
            .buildHardDisk()
            .buildMemory()
            .buildDisplayCard()
            .buildMainBoard()
            .buildKeyboard()
            .buildMouse()
            .buildPower()
            .build();
    System.out.println("appleComputer = " + appleComputer);
}
```

![image-20220606152203988](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206061522196.png)

#### 3.6.3 优缺点

1. 优点

- 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。

- 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合“开闭原则”

- 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。

2. 缺点

- 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。

- 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。

#### 3.6.4 适用场景

(1) 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。

(2) 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。

(3) 对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。

(4) 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。

## 4. 七个结构型模式

> 1. 适配器模式
> 2. 桥接模式
> 3. 组合模式
> 4. 装饰模式
> 5. 外观模式
> 6. 享元模式
> 7. 代理模式

### 4.1 适配器模式

> **适配器模式(Adapter Pattern)**：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(`Wrapper`)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。
>
> **注：在适配器模式定义中所提及的接口是指广义的接口，它可以表示一个方法或者方法的集合。**

#### 4.1.1 在对象适配器模式结构图中包含如下几个角色

- **Target（目标抽象类）**：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。
- **Adapter（适配器类）**：适配器可以调用另一个接口，作为一个转换器，对`Adaptee`和`Target`进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承`Target`并关联一个`Adaptee`对象使二者产生联系。
- **Adaptee（适配者类）**：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。

#### 4.1.2 对象适配器实现

1. 两个适配者类

这两个类都比较垃圾，只能计算int类型的。但是客户输入是字符串型的不定长。所以就需要适配器中间做一下转换。

```java
public class AddSubCalculate {

    public int add(int a, int b) {
        return a + b;
    }

    public int sub(int a, int b) {
        return a - b;
    }
}

public class MultiplyDivideCalculate {

    public int multiply(int a, int b) {
        return a * b;
    }

    public int divide(int a, int b) {
        return a / b;
    }
}
```

2. 目标轴向类

可以理解为用户看到的接口，满足用户需求的接口。

```java
public interface Arithmetic {
    int add(String ...a);

    int sub(String ...a);

    int multiply(String ...a);

    int divide(String... a);
}
```

3. 中间适配层

这里只是演示可行性，不去处理异常情况

```java
public class ArithmeticAdapter implements Arithmetic {
    private AddSubCalculate addSubCalculate;
    private MultiplyDivideCalculate multiplyDivideCalculate;

    public ArithmeticAdapter() {
        addSubCalculate = new AddSubCalculate();
        multiplyDivideCalculate = new MultiplyDivideCalculate();
    }

    @Override
    public int add(String... a) {
        int sum = 0;
        for (String s : a) {
            int i = Integer.parseInt(s);
            sum = addSubCalculate.add(sum, i);
        }
        return sum;
    }

    @Override
    public int sub(String... a) {
        int sub = 2 * Integer.parseInt(a[0]);
        for (String s : a) {
            int i = Integer.parseInt(s);
            sub = addSubCalculate.sub(sub, i);
        }
        return sub;
    }

    @Override
    public int multiply(String... a) {
        int mult = 1;
        for (String s : a) {
            int i = Integer.parseInt(s);
            mult = multiplyDivideCalculate.multiply(mult, i);
        }
        return mult;
    }

    @Override
    public int divide(String... a) {
        int a0 = Integer.parseInt(a[0]);
        int div = a0 * a0;
        for (String s : a) {
            int i = Integer.parseInt(s);
            div = multiplyDivideCalculate.divide(div, i);
        }
        return div;
    }
}
```

4. 测试

```java
public static void main(String[] args) {
    Arithmetic arithmetic = new ArithmeticAdapter();
    int add = arithmetic.add("1", "2", "3", "4", "5", "6", "7", "8");
    int sub = arithmetic.sub("15", "1", "2", "3", "4");
    int multiply = arithmetic.multiply("1", "2", "3", "4", "5", "6", "7");
    int divide = arithmetic.divide("16", "2", "4", "1");
    System.out.println("add = " + add);
    System.out.println("sub = " + sub);
    System.out.println("multiply = " + multiply);
    System.out.println("divide = " + divide);
}
```

![image-20220606170411143](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206061704212.png)

5. 小总结

不用动原有代码，加了一层适配器，解决了客户的需求

#### 4.1.3 类适配器

> 类适配器模式和对象适配器模式最大的区别在于适配器和适配者之间的关系不同，对象适配器模式中适配器和适配者之间是关联关系，而类适配器模式中适配器和适配者是继承关系
>
> 因为java不支持多继承，所以类适配器受到很多限制，较少使用

```java
public class ArithmeticClassAdapter extends AddSubCalculate implements Arithmetic{
    @Override
    public int add(String... a) {
        int sum = 0;
        for (String s : a) {
            int i = Integer.parseInt(s);
            sum = this.add(sum,i);
        }
        return sum;
    }

    @Override
    public int sub(String... a) {
        int sub = 2 * Integer.parseInt(a[0]);
        for (String s : a) {
            int i = Integer.parseInt(s);
            sub = this.sub(sub, i);
        }
        return sub;
    }

    @Override
    public int multiply(String... a) {
        return 0;
    }

    @Override
    public int divide(String... a) {
        return 0;
    }
}

//测试
arithmetic = new ArithmeticClassAdapter();
int add2 = arithmetic.add("1", "2", "3", "4", "5", "6", "7", "8");
int sub2 = arithmetic.sub("15", "1", "2", "3", "4");
System.out.println("add2 = " + add2);
System.out.println("sub2 = " + sub2);
```

![image-20220606173327129](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206061733242.png)

#### 4.1.4 双向适配器

> 在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，那么该适配器就是一个双向适配器
>
> 用处不大，实现复杂。所以实际开发中基本上不使用。这里作为了解

#### 4.1.5 缺省适配器

> **缺省适配器模式(Default Adapter Pattern)**：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。

1. 缺省适配器中包括
   - **ServiceInterface（适配者接口）**：它是一个接口，通常在该接口中声明了大量的方法。
   - **AbstractServiceClass（缺省适配器类）**：它是缺省适配器模式的核心类，使用空方法的形式实现了在ServiceInterface接口中声明的方法。通常将它定义为抽象类，因为对它进行实例化没有任何意义。
   - **ConcreteServiceClass（具体业务类）**：它是缺省适配器类的子类，在没有引入适配器之前，它需要实现适配者接口，因此需要实现在适配者接口中定义的所有方法，而对于一些无须使用的方法也不得不提供空实现。在有了缺省适配器之后，可以直接继承该适配器类，根据需要有选择性地覆盖在适配器类中定义的方法。

2. 代码

```java
//用户接口
public interface Calculate {
    int add(String... a);

    int sub(String... a);

    int multiply(String... a);

    int divide(String... a);
}

//缺省适配器类
public abstract class AbsCalculate implements Calculate{
    @Override
    public int sub(String... a) {
        System.out.println("父类");
        int sub = 2 * Integer.parseInt(a[0]);
        for (String s : a) {
            int i = Integer.parseInt(s);
            sub = sub - i;
        }
        return sub;
    }

    @Override
    public int multiply(String... a) {
        return 0;
    }

    @Override
    public int divide(String... a) {
        return 0;
    }
}
//具体业务子类
public class AbsCalculateExt extends AbsCalculate {
    private AddSubCalculate addSubCalculate;

    public AbsCalculateExt() {
        addSubCalculate = new AddSubCalculate();
    }

    @Override
    public int add(String... a) {
        System.out.println("子类");
        int sum = 0;
        for (String s : a) {
            int i = Integer.parseInt(s);
            sum = addSubCalculate.add(sum, i);
        }
        return sum;
    }
}
//测试
Calculate calculate = new AbsCalculateExt();
int add3 = calculate.add("1", "2", "3", "4", "5", "6", "7", "8");
int sub3 = calculate.sub("15", "1", "2", "3", "4");
System.out.println("add3 = " + add3);
System.out.println("sub3 = " + sub3);
```

![image-20220606174846152](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206061748255.png)

#### 4.1.6 总结

1. 优点
   - 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。
   - 增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用
   - 由于适配器类是适配者类的子类，因此**可以在适配器类中置换一些适配者的方法**，使得适配器的灵活性更强。
   - 一个对象适配器**可以把多个不同的适配者适配到同一个目标**；
   - **可以适配一个适配者的子类**，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。

2. 缺点

   类适配器：

   -  对于Java、C#等不支持多重类继承的语言，一次最多只能适配一个适配者类，**不能同时适配多个适配者**；
   -  **适配者类不能为最终类**，如在Java中不能为final类，C#中不能为sealed类；
   - 在Java、C#等语言中，**类适配器模式中的目标抽象类只能为接口，不能为类**，其使用有一定的局限性

   对象适配器：

   -  与类适配器模式相比，**要在适配器中置换适配者类的某些方法比较麻烦**。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。

3. 适用情况

   ​    (1) 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。

   ​    (2) 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。

### 4.2 桥接模式

> **桥接模式(Bridge Pattern)**：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
>
> 它是一种对象结构型模式，又称为柄体**(`Handle and Body`)**模式或接口**(`Interface`)**模式。

#### 4.2.1 桥接模式结构图中包含如下几个角色

- **Abstraction（抽象类）**：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。
- **RefinedAbstraction（扩充抽象类）**：扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。
- **Implementor（实现类接口）**：定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同，一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。Implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系来替代继承关系。
- **ConcreteImplementor（具体实现类）**：具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。

#### 4.2.2 概念理解

好jb抽象

![Factory](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206071115409.png)

> 需求：需要制造电脑，根据用户输入，制造出对应的笔记本电脑、平板电脑、台式机以及对应厂家生产的这几种电脑。

1. 需求分析

电脑 -> 电脑类别 -> 电脑厂商对应的电脑类别

这三个是依次继承的关系，如果直接写，那么对应的类写的就会很多。定义一个电脑类，下面继承三个子类，三个子类分别各自继承四个子类。这样下来就会有16个类。而且，如果再添加一个电脑类别或者厂商的话，就会增加的比较多，而且还需要改现有代码。

2. 痛点解决

   先看类图，然后掌握整个架构。咱们逐步分析。

   2.1 先将厂家单独拎出来

   ​	定义一个厂家的接口，不管他制造那个种类，先给他个制造的方法。让他的子类实现这个制造方法，自定义各自的制造方法。

   2.2 然后将种类也单独拎出来

   ​	定义一个抽象类，先在种类里面加一个设置厂家的方法。这一步很关键，将厂家和种类关联起来了。

   ​	然后让种类的子类去继承这个抽象类。然后覆写父类里面的方法实现需求。

   ​	当然调用厂家里面的相关方法就可以在这里调用了，因为前面已经设置过厂家了。

   2.3 使用

   ​	使用的时候就很方便了。用户根据自己的需求，先定义一个厂家，然后定义一个种类，把定义好的厂家设置到种类里面。然后调用种类里面的相关方法就能够完成需求。

   ​	这样的话，无论是新添加一个种类还是新添加一个厂家就直接实现父类就可以。无需修改现有代码。

#### 4.2.3 代码

1. 工厂接口

```java
public interface Factory {
    public void manufacture();
}
```

2. 工厂实现

```java
public class AppleFactory implements Factory {
    @Override
    public void manufacture() {
        System.out.print("AppleFactory制造，");
    }
}

public class DellFactory implements Factory {
    @Override
    public void manufacture() {
        System.out.print("DellFactory制造，");
    }
}

public class LenovoFactory implements Factory {
    @Override
    public void manufacture() {
        System.out.print("LenovoFactory制造，");
    }
}

public class MiFactory implements Factory {
    @Override
    public void manufacture() {
        System.out.print("MiFactory制造，");
    }
}
```

3. 种类抽象类

```java
public abstract class Computer {
    protected Factory factory;

    public Computer setFactory(Factory factory) {
        this.factory = factory;
        return this;
    }

    public void classification(String name) {
        this.factory.manufacture();
    }
}
```

4. 种类子类

```java
public class desktopComputer extends Computer {
    @Override
    public void classification(String name) {
        super.classification(name);
        System.out.println("desktopComputer,名字为：" + name);
    }
}

public class laptopComputer extends Computer {
    @Override
    public void classification(String name) {
        super.classification(name);
        System.out.println("laptopComputer,名字为：" + name);
    }
}

public class tabletComputer extends Computer {
    @Override
    public void classification(String name) {
        super.classification(name);
        System.out.println("tabletComputer,名字为：" + name);
    }
}
```

5. 测试

```java
public static void main(String[] args) {
    Computer computer = new laptopComputer();
    Factory factory = new MiFactory();
    computer.setFactory(factory).classification("i7");
    computer = new tabletComputer();
    factory = new DellFactory();
    computer.setFactory(factory).classification("i5");
    computer = new desktopComputer();
    factory = new LenovoFactory();
    computer.setFactory(factory).classification("i3");
    factory = new AppleFactory();
    computer.setFactory(factory).classification("i9");
}
```

![image-20220607113352925](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206071133035.png)

#### 4.2.4 总结

1. 优点

- 分离抽象接口及其实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，也就是说抽象和实现不再在同一个继承层次结构中，而是“子类化”它们，使它们各自都具有自己的子类，以便任何组合子类，从而获得多维度组合对象。
- 在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了“单一职责原则”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数。
- 桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”。

2. 缺点

- 桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。
- 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。

3. 适用场景

- 如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。
- “抽象部分”和“实现部分”可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。
- 一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。
- 对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。

### 4.3 组合模式

> **组合模式(Composite Pattern)**：组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。
>
> 组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”`(Part-Whole)`模式，它是一种对象结构型模式。

#### 4.3.1 组合模式结构图中包含如下几个角色

- **Component（抽象构件）**：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。
- **Leaf（叶子构件）**：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。
- **Composite（容器构件）**：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。

> **组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。**

#### 4.3.2 组合模式简单实现（透明）

```java
//抽象文件类
public abstract class AbstractFile {
    public abstract void add(AbstractFile file);

    public abstract void  remove(AbstractFile file);

    public abstract AbstractFile getChild(int i);

    public abstract void kill();
}

//图像文件子类
public class ImageFile extends AbstractFile{
    private String name;

    public ImageFile(String name) {
        this.name = name;
    }

    @Override
    public void add(AbstractFile file) {
        System.out.println("不支持该操作");
    }

    @Override
    public void remove(AbstractFile file) {
        System.out.println("不支持该操作");
    }

    @Override
    public AbstractFile getChild(int i) {
        System.out.println("不支持该操作");
        return null;
    }

    @Override
    public void kill() {
        System.out.println("===对图像文件杀毒：name：" + name);
    }
}

//文本文件子类
public class TextFile extends AbstractFile{
    private String name;

    public TextFile(String name) {
        this.name = name;
    }

    @Override
    public void add(AbstractFile file) {
        System.out.println("不支持该操作");
    }

    @Override
    public void remove(AbstractFile file) {
        System.out.println("不支持该操作");
    }

    @Override
    public AbstractFile getChild(int i) {
        System.out.println("不支持该操作");
        return null;
    }

    @Override
    public void kill() {
        System.out.println("===对文本文档杀毒：name：" + name);
    }
}

//视频文件子类
public class VideoFile extends AbstractFile{
    private String name;

    public VideoFile(String name) {
        this.name = name;
    }

    @Override
    public void add(AbstractFile file) {
        System.out.println("不支持该操作");
    }

    @Override
    public void remove(AbstractFile file) {
        System.out.println("不支持该操作");
    }

    @Override
    public AbstractFile getChild(int i) {
        System.out.println("不支持该操作");
        return null;
    }

    @Override
    public void kill() {
        System.out.println("===对视频文件杀毒：name：" + name);
    }
}

//测试
public static void main(String[] args) {
    AbstractFile img1,img2,img3,txt1,txt2,txt3,video1,video2,video3,folder1,folder2,folder3,folder4;
    img1 = new ImageFile("img1");
    img2 = new ImageFile("img2");
    img3 = new ImageFile("img3");
    txt1 = new TextFile("txt1");
    txt2 = new TextFile("txt2");
    txt3 = new TextFile("txt3");
    video1 = new VideoFile("video1");
    video2 = new VideoFile("video2");
    video3 = new VideoFile("video3");
    folder1 = new Folder("folder1");
    folder2 = new Folder("folder2");
    folder3 = new Folder("folder3");
    folder4 = new Folder("folder4");
    folder1.add(img1);
    folder1.add(txt1);
    folder1.add(video1);
    folder2.add(img2);
    folder2.add(txt2);
    folder2.add(video2);
    folder2.add(folder1);
    folder3.add(img3);
    folder3.add(txt3);
    folder3.add(video3);
    folder3.add(folder2);
    folder4.add(folder3);
    folder4.kill();
}
```

![image-20220607152757209](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206071527358.png)

就感觉很牛逼，啥都没干，突然就啥都有了。

#### 4.3.3 组合模式优化实现（透明）

> 给叶子节点用不到的几个方法，添加默认实现。这样叶子就不用重写，只有容器重写就可以。
>
> 比较简单，但是不安全

```java
public abstract class AbstractFile {
    public  void add(AbstractFile file){
        System.out.println("不支持该操作");
    }

    public  void  remove(AbstractFile file){
        System.out.println("不支持该操作");
    }

    public  AbstractFile getChild(int i){
        System.out.println("不支持该操作");
        return null;
    }

    public abstract void kill();
}

public class Folder extends AbstractFile {
    private String name;
    private List<AbstractFile> childList = new ArrayList<>();

    public Folder(String name) {
        this.name = name;
    }

    @Override
    public void add(AbstractFile file) {
        childList.add(file);
    }

    @Override
    public void remove(AbstractFile file) {
        childList.remove(file);
    }

    @Override
    public AbstractFile getChild(int i) {
        return childList.get(i);
    }

    @Override
    public void kill() {
        System.out.println("===对文件夹进行杀毒：name：" + name);
        for (AbstractFile abstractFile : childList) {
            abstractFile.kill();
        }
    }
}

public class ImageFile extends AbstractFile {
    private String name;

    public ImageFile(String name) {
        this.name = name;
    }

    @Override
    public void kill() {
        System.out.println("===对图像文件杀毒：name：" + name);
    }
}

public class TextFile extends AbstractFile {
    private String name;

    public TextFile(String name) {
        this.name = name;
    }

    @Override
    public void kill() {
        System.out.println("===对文本文档杀毒：name：" + name);
    }
}

public class VideoFile extends AbstractFile {
    private String name;

    public VideoFile(String name) {
        this.name = name;
    }

    @Override
    public void kill() {
        System.out.println("===对视频文件杀毒：name：" + name);
    }
}

public static void main(String[] args) {
    AbstractFile img1, img2, img3, txt1, txt2, txt3, video1, video2, video3, folder1, folder2, folder3, folder4;
    img1 = new ImageFile("img1");
    img2 = new ImageFile("img2");
    img3 = new ImageFile("img3");
    txt1 = new TextFile("txt1");
    txt2 = new TextFile("txt2");
    txt3 = new TextFile("txt3");
    video1 = new VideoFile("video1");
    video2 = new VideoFile("video2");
    video3 = new VideoFile("video3");
    folder1 = new Folder("folder1");
    folder2 = new Folder("folder2");
    folder3 = new Folder("folder3");
    folder4 = new Folder("folder4");
    folder1.add(img1);
    folder1.add(txt1);
    folder1.add(video1);
    folder2.add(img2);
    folder2.add(txt2);
    folder2.add(video2);
    folder2.add(folder1);
    folder3.add(img3);
    folder3.add(txt3);
    folder3.add(video3);
    folder3.add(folder2);
    folder4.add(folder3);
    folder4.kill();
}
```

![image-20220607155452283](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206071554407.png)

4.3.4 组合模式实现（安全）

> 抽象类里面直接不定义几个方法，放到容器里面定义。这样比较安全。
>
> 但是使用的时候需要用到容器进行实例化，不能使用抽象类
>
> 安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。

```java
public abstract class AbstractFile {
    public abstract void kill();
}

public class Folder extends AbstractFile {
    private String name;
    private List<AbstractFile> childList = new ArrayList<>();

    public Folder(String name) {
        this.name = name;
    }

    public void add(AbstractFile file) {
        childList.add(file);
    }

    public void remove(AbstractFile file) {
        childList.remove(file);
    }

    public AbstractFile getChild(int i) {
        return childList.get(i);
    }

    @Override
    public void kill() {
        System.out.println("===对文件夹进行杀毒：name：" + name);
        for (AbstractFile abstractFile : childList) {
            abstractFile.kill();
        }
    }
}

public class ImageFile extends AbstractFile {
    private String name;

    public ImageFile(String name) {
        this.name = name;
    }

    @Override
    public void kill() {
        System.out.println("===对图像文件杀毒：name：" + name);
    }
}

public class TextFile extends AbstractFile {
    private String name;

    public TextFile(String name) {
        this.name = name;
    }

    @Override
    public void kill() {
        System.out.println("===对文本文档杀毒：name：" + name);
    }
}

public class VideoFile extends AbstractFile {
    private String name;

    public VideoFile(String name) {
        this.name = name;
    }

    @Override
    public void kill() {
        System.out.println("===对视频文件杀毒：name：" + name);
    }
}

public static void main(String[] args) {
    AbstractFile img1, img2, img3, txt1, txt2, txt3, video1, video2, video3;
    Folder folder1, folder2, folder3, folder4;
    img1 = new ImageFile("img1");
    img2 = new ImageFile("img2");
    img3 = new ImageFile("img3");
    txt1 = new TextFile("txt1");
    txt2 = new TextFile("txt2");
    txt3 = new TextFile("txt3");
    video1 = new VideoFile("video1");
    video2 = new VideoFile("video2");
    video3 = new VideoFile("video3");
    folder1 = new Folder("folder1");
    folder2 = new Folder("folder2");
    folder3 = new Folder("folder3");
    folder4 = new Folder("folder4");
    folder1.add(img1);
    folder1.add(txt1);
    folder1.add(video1);
    folder2.add(img2);
    folder2.add(txt2);
    folder2.add(video2);
    folder2.add(folder1);
    folder3.add(img3);
    folder3.add(txt3);
    folder3.add(video3);
    folder3.add(folder2);
    folder4.add(folder3);
    folder4.kill();
}
```

![image-20220607160001822](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206071600968.png)

#### 4.3.4 总结

组合模式使用面向对象的思想来实现树形结构的构建与处理，描述了如何将容器对象和叶子对象进行递归组合，实现简单，灵活性好。

1. 优点

  (1) 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。

  (2) 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。

  (3) 在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”。

  (4) 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。

2. 缺点

在增加新构件时很难对容器中的构件类型进行限制。有时候我们希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。

3. 适用场景

  (1) 在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。

  (2) 在一个使用面向对象语言开发的系统中需要处理一个树形结构。

  (3) 在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。

> Java SE中的AWT和Swing包的设计就基于组合模式,还有XML解析、组织结构树处理、文件系统设计等领域适用较多。

### 4.4 装饰模式

> **装饰模式(Decorator Pattern)**：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。
>
> 装饰模式是一种对象结构型模式。
>
> 装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。

#### 4.4.1 装饰模式结构图中包含如下几个角色

- **Component（抽象构件）**：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。
- **ConcreteComponent（具体构件）**：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。
- **Decorator（抽象装饰类）**：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。
- **ConcreteDecorator（具体装饰类）**：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。

#### 4.4.2 代码实现

```java
//构建类
public abstract class Computer {
    public abstract void build();
}
//构建实现类
public class AppleComputer extends Computer {
    @Override
    public void build() {
        System.out.println("建造苹果电脑！");
    }
}

public class DellComputer extends Computer {
    @Override
    public void build() {
        System.out.println("建造Dell电脑！");
    }
}

public class LenovoComputer extends Computer {
    @Override
    public void build() {
        System.out.println("建造联想电脑！");
    }
}
```

```java
//装饰类
public abstract class ComputerDecorator extends Computer{
    private Computer computer;

    public ComputerDecorator(Computer computer) {
        this.computer = computer;
    }

    @Override
    public void build() {
        computer.build();
    }
}

public class ColorDecorator extends ComputerDecorator {

    public ColorDecorator(Computer computer) {
        super(computer);
    }

    @Override
    public void build() {
        this.addColor("red");
        super.build();
    }

    public void addColor(String color) {
        System.out.println("添加颜色：" + color);
    }
}

public class ShapeDecorator extends ComputerDecorator {
    public ShapeDecorator(Computer computer) {
        super(computer);
    }

    @Override
    public void build() {
        this.addShape("circle");
        super.build();
    }

    public void  addShape(String shape) {
        System.out.println("添加形状：" + shape);
    }
}
```

```java
//测试
public static void main(String[] args) {
    Computer computer = new DellComputer();
    Computer colorDecorator = new ColorDecorator(computer);
    colorDecorator.build();
    System.out.println("----------------------------------------------------");
    Computer appleComputer = new AppleComputer();
    Computer appleDecorator = new ShapeDecorator(appleComputer);
    appleDecorator.build();
    System.out.println("----------------------------------------------------");
    Computer dellComputer = new DellComputer();
    Computer dellColorDecorator = new ColorDecorator(dellComputer);
    Computer dellShapeDecorator = new ShapeDecorator(dellColorDecorator);
    dellShapeDecorator.build();
}
```

![image-20220614164510512](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206141645728.png)

#### 4.4.3 总结

一句话来说就是在原有基础不动的前提下，进行业务的扩充。

1. 优点
   - 对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。
   - 可以通过一种动态的方式来扩展一个对象的功能。
   - 可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。
   - 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。
2. 缺点
   - 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。
   - 装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。
3. 适用场景
   - 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
   - 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类已定义为不能被继承（如Java语言中的final类）。

### 4.5 外观模式

> **外观模式（**Facade Pattern**）：**为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
>
> 外观模式中，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。
>
>  外观模式又称为门面模式，它是一种对象结构型模式。
>
> 外观模式是迪米特法则的一种具体实现，通过引入一个新的外观角色可以降低原有系统的复杂度，同时降低客户类与子系统的耦合度。

![image-20220614165339630](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206141653713.png)

#### 4.5.1 外观模式包含如下两个角色

  (1) **Facade（外观角色）**：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。

  (2) **SubSystem（子系统角色）**：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。

#### 4.5.2 简单代码实现

> 张三怎么过一天进行举例子

```java
//子系统
public class Book {
    public void open(){
        System.out.println("把书翻开放桌子上");
    }
}
public class Computer {
    public void watch(){
        System.out.println("玩电脑11.9小时");
    }
}
public class Phone {
    public void play(){
        System.out.println("玩手机10小时");
    }
}

//外观角色
public class ZhangSanDeYiTianFacade {
    private Phone phone;
    private Book book;
    private Computer computer;

    public ZhangSanDeYiTianFacade() {
        phone = new Phone();
        book = new Book();
        computer = new Computer();
    }

    public void overThisDay(){
        book.open();
        phone.play();
        computer.watch();
    }
}
//测试
public static void main(String[] args) {
    ZhangSanDeYiTianFacade zhangSanDeYiTianFacade = new ZhangSanDeYiTianFacade();
    zhangSanDeYiTianFacade.overThisDay();
}
```

![image-20220614170259636](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206141702741.png)

#### 4.5.3 加入抽象类

> 如果张三不想这么沉沦下去了。决定不玩手机不玩电脑，只看书。

```java
public interface YiTianDacade {
    public void overThisDay();
}

public class ZhangSanFightYiTian implements YiTianDacade {
    private Book book;

    public ZhangSanFightYiTian() {
        book = new Book();
    }

    @Override
    public void overThisDay() {
        book.open();
    }
}

public static void main(String[] args) {
    YiTianDacade zhangSanDeYiTianFacade = new ZhangSanDeYiTianFacade();
    zhangSanDeYiTianFacade.overThisDay();
    System.out.println("=============改变==================");
    YiTianDacade zhangSanFightYiTian = new ZhangSanFightYiTian();
    zhangSanFightYiTian.overThisDay();
}
```

![image-20220614170854514](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206141708695.png)

#### 4.5.4 总结

1. 优点
   - 它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。
   - 它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。
   - 一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。
2. 缺点
   - 不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。
   - 如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。
3. 适用场景
   - 当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。
   - 客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。
   - 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。

### 4.6 享元模式

> **享元模式(Flyweight Pattern)**：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。

#### 4.6.1 相关概念

1. 享元池(Flyweight Pool)

   享元模式通过共享技术实现相同或相似对象的重用，**在逻辑上每一个出现的字符都有一个对象与之对应，然而在物理上它们却共享同一个享元对象**，这个对象可以出现在一个字符串的不同地方，相同的字符对象都指向同一个实例，在享元模式中，存储这些共享实例对象的地方称为**享元池**

2. 享元的内部状态

   **内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享**。

   如字符的内容，不会随外部环境的变化而变化，无论在任何环境下字符“a”始终是“a”，都不会变成“b”。

3. 享元的外部状态

   外部状态是随环境改变而改变的、不可以共享的状态。

   享元对象的外部状态通常由客户端保存，并在享元对象被创建之后，需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。

   如字符的颜色，可以在不同的地方有不同的颜色，例如有的“a”是红色的，有的“a”是绿色的，字符的大小也是如此，有的“a”是五号字，有的“a”是四号字。而且字符的颜色和大小是两个独立的外部状态，它们可以独立变化，相互之间没有影响，客户端可以在使用时将外部状态注入享元对象中。

#### 4.6.2 享元模式结构图中包含如下几个角色

  ● **Flyweight（抽象享元类）**：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。

  ● **ConcreteFlyweight（具体享元类）**：它实现了抽象享元类，其实例称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。

  ● **UnsharedConcreteFlyweight（非共享具体享元类）**：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。

  ● **FlyweightFactory（享元工厂类）**：享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储“键值对”的集合（也可以是其他类型的集合），可以结合工厂模式进行设计；当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例或者创建一个新的实例（如果不存在的话），返回新创建的实例并将其存储在享元池中。

#### 4.6.3 简单实现

图书馆里面只有三本书，语数外，不管谁借借到的都会是同一本书。

```java
public abstract class Book {
    public abstract String getBook();

    public void read(){
        System.out.println("读书,读的什么书？" + this.getBook());
    }
}

public class ChineseBook extends Book {
    @Override
    public String getBook() {
        return "中文书";
    }
}

public class MathBook extends Book {
    @Override
    public String getBook() {
        return "数学书";
    }
}

public class EnglishBook extends Book {
    @Override
    public String getBook() {
        return "英语书";
    }
}
```

享元池实现，用单例构造，用HashTable进行存储。

```java
public enum LibraryFactory {
    /**
     * 实例
     */
    INSTANCE;

    private final static Hashtable<String, Book> BOOK_TABLE = new Hashtable<>();

    public Book borrowBook(String bookType) {
        if (BOOK_TABLE.containsKey(bookType)) {
            return BOOK_TABLE.get(bookType);
        } else {
            Book b;
            switch (bookType) {
                case "e":
                    b = new EnglishBook();
                    break;
                case "m":
                    b = new MathBook();
                    break;
                case "c":
                    b = new ChineseBook();
                    break;
                default:
                    b = null;
                    break;
            }
            if (b != null) {
                BOOK_TABLE.put(bookType, b);
            }
            return b;
        }
    }
}
```

测试

```java
public static void main(String[] args) {
    Book english1, english2, english3, math1, math2, chinese1, chinese2;
    english1 = LibraryFactory.INSTANCE.borrowBook("e");
    english2 = LibraryFactory.INSTANCE.borrowBook("e");
    english3 = LibraryFactory.INSTANCE.borrowBook("e");
    math1 = LibraryFactory.INSTANCE.borrowBook("m");
    math2 = LibraryFactory.INSTANCE.borrowBook("m");
    chinese1 = LibraryFactory.INSTANCE.borrowBook("c");
    chinese2 = LibraryFactory.INSTANCE.borrowBook("c");
    System.out.println("判断借出的书是不是同一本书：" + (english1 == english2));
    System.out.println("判断借出的书是不是同一本书：" + (math1 == math2));
    System.out.println("判断借出的书是不是同一本书：" + (chinese1 == chinese2));
    english1.read();
    english2.read();
    english3.read();
    math1.read();
    math2.read();
    chinese1.read();
    chinese2.read();
}
```

![image-20220615153127686](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206151531900.png)

#### 4.6.4 带外部状态的解决方案

添加一个条件类

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ConditionIndex {
    private Integer page;
    private Integer row;
    private Integer col;
}
```

Book抽象类改为

```java
public abstract class Book {
    public abstract String getBook();

    public void read(ConditionIndex index) {
        System.out.println("读书,读的什么书？" + this.getBook() + "。读的第" + index.getPage() + "页" + "，第" + index.getRow() + "行" + "，第" + index.getCol() + "列");
    }
}
```

测试

```java
public static void main(String[] args) {
    Book english1, english2, english3, math1, math2, chinese1, chinese2;
    english1 = LibraryFactory.INSTANCE.borrowBook("e");
    english2 = LibraryFactory.INSTANCE.borrowBook("e");
    english3 = LibraryFactory.INSTANCE.borrowBook("e");
    math1 = LibraryFactory.INSTANCE.borrowBook("m");
    math2 = LibraryFactory.INSTANCE.borrowBook("m");
    chinese1 = LibraryFactory.INSTANCE.borrowBook("c");
    chinese2 = LibraryFactory.INSTANCE.borrowBook("c");
    System.out.println("判断借出的书是不是同一本书：" + (english1 == english2));
    System.out.println("判断借出的书是不是同一本书：" + (math1 == math2));
    System.out.println("判断借出的书是不是同一本书：" + (chinese1 == chinese2));
    english1.read(new ConditionIndex(1,1,1));
    english2.read(new ConditionIndex(2, 3, 4));
    english3.read(new ConditionIndex(5, 6, 7));
    math1.read(new ConditionIndex(4, 6, 8));
    math2.read(new ConditionIndex(2, 3, 7));
    chinese1.read(new ConditionIndex(5, 2, 1));
    chinese2.read(new ConditionIndex(9, 32, 45));
}
```

![image-20220615154043570](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206151544594.png)

#### 4.6.5 单纯享元模式和复合享元模式

1. 单纯享元模式

   > 在单纯享元模式中，所有的具体享元类都是可以共享的，不存在非共享具体享元类。

2. 复合享元模式

   > 将一些单纯享元对象使用组合模式加以组合，还可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。

通过复合享元模式，可以确保复合享元类CompositeConcreteFlyweight中所包含的每个单纯享元类ConcreteFlyweight都具有相同的外部状态，而这些单纯享元的内部状态往往可以不同。如果希望为多个内部状态不同的享元对象设置相同的外部状态，可以考虑使用复合享元模式。

#### 4.6.6 总结

1. 优点

   ​    (1) 可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。

   ​    (2) 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。

2. 缺点

   ​    (1) 享元模式使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。

   ​    (2) 为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。

3. 适用场景

      (1) 一个系统有大量相同或者相似的对象，造成内存的大量耗费。

      (2) 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。

      (3) 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。

### 4.7 代理模式

> **代理模式（Proxy Pattern）：**给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。
>
>  代理模式是一种对象结构型模式。在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。
>
> 代理模式是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。
>
> 根据代理模式的使用目的不同，代理模式又可以分为多种类型，例如保护代理、远程代理、虚拟代理、缓冲代理等，它们应用于不同的场合，满足用户的不同需求。

#### 4.7.1 代理模式包含如下三个角色

1. **Subject（抽象主题角色）**

   它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。

2. **Proxy（代理主题角色）**

   它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。

3. **RealSubject（真实主题角色）**

   它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。

#### 4.7.2 常用的几种代理模式

1. **远程代理(Remote Proxy)**

   为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使(Ambassador)。

2. **虚拟代理(Virtual Proxy)**

   如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。

3. **保护代理(Protect Proxy)**

   控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。

4. **缓冲代理(Cache Proxy)**

   为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。

5. **智能引用代理(Smart Reference Proxy)**

   当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。

#### 4.7.3 保护代理和智能引用代理

```java
//权限认证
public class AccessValidator {
    private List<String> whiteList = Arrays.asList("admin", "user");

    public boolean validate(String userId) {
        System.out.println("校验用户权限，进行登录。用户名：" + userId);
        if (whiteList.contains(userId)) {
            System.out.println("登录成功！");
            return true;
        }
        System.out.println("登录失败！");
        return false;
    }
}

//日志记录
public class LoggerRecord {
    public void record(String userId, String keyword) {
        System.out.println("记录日志，用户名：" + userId + "，搜索关键字：" + keyword + ",搜索次数加一");
    }
}

//抽象查询类
public interface Searcher {
    public String doSearch(String userId,String keyword);
}

//实际查询
public class RealSearcher implements Searcher{
    @Override
    public String doSearch(String userId, String keyword) {
        return "搜索用户：" + userId + "，关键字：" + keyword + "，搜索结果：啦啦啦啦啦啦啦啦阿联";
    }
}

//代理
public class ProxySearcher implements Searcher{

    private RealSearcher realSearcher = new RealSearcher();
    private AccessValidator accessValidator;
    private LoggerRecord loggerRecord;


    @Override
    public String doSearch(String userId, String keyword) {
        accessValidator = new AccessValidator();
        if (accessValidator.validate(userId)) {
            loggerRecord = new LoggerRecord();
            loggerRecord.record(userId, keyword);
            return realSearcher.doSearch(userId, keyword);
        }
        return null;
    }

}

//测试
public static void main(String[] args) {
    ProxySearcher proxySearcher = new ProxySearcher();
    String s1 = proxySearcher.doSearch("admin", "java");
    System.out.println("s1 = " + s1);
    System.out.println("----------------------------------------------------");
    String s2 = proxySearcher.doSearch("user", "ccc");
    System.out.println("s2 = " + s2);
    System.out.println("----------------------------------------------------");
    String s3 = proxySearcher.doSearch("qwe", "java");
    System.out.println("s3 = " + s3);
}
```

![image-20220628093042362](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206280930704.png)

> 很明显，spring里面切面的思想就是根据这个做的。

#### 4.7.4 远程代理

> **远程代理(Remote Proxy)**是一种常用的代理模式，它使得客户端程序可以访问在远程主机上的对象，远程主机可能具有更好的计算性能与处理速度，可以快速响应并处理客户端的请求。远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户端完全可以认为被代理的远程业务对象是在本地而不是在远程，而远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用。
>
> VPN

#### 4.7.5 虚拟代理

> **虚拟代理(Virtual Proxy)**也是一种常用的代理模式，对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象。

在以下两种情况下可以考虑使用虚拟代理：

- 由于对象本身的复杂性或者网络等原因导致一个对象需要较长的加载时间，此时可以用一个加载时间相对较短的代理对象来代表真实对象。

  通常在实现时可以结合多线程技术，一个线程用于显示代理对象，其他线程用于加载真实对象。这种虚拟代理模式可以应用在程序启动的时候，由于创建代理对象在时间和处理复杂度上要少于创建真实对象，因此，在程序启动时，可以用代理对象代替真实对象初始化，大大加速了系统的启动时间。当需要使用真实对象时，再通过代理对象来引用，而此时真实对象可能已经成功加载完毕，可以缩短用户的等待时间。

- 当一个对象的加载十分耗费系统资源的时候，也非常适合使用虚拟代理。

  虚拟代理可以让那些占用大量内存或处理起来非常复杂的对象推迟到使用它们的时候才创建，而在此之前用一个相对来说占用资源较少的代理对象来代表真实对象，再通过代理对象来引用真实对象。为了节省内存，在第一次引用真实对象时再创建对象，并且该对象可被多次重用，在以后每次访问时需要检测所需对象是否已经被创建，因此在访问该对象时需要进行存在性检测，这需要消耗一定的系统时间，但是可以节省内存空间，这是一种用时间换取空间的做法。

#### 4.7.6 缓冲代理

>  **缓冲代理(Cache Proxy)**也是一种较为常用的代理模式，它为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，从而可以避免某些方法的重复执行，优化系统性能。

#### 4.7.7 代理模式优点

1. 共同优点

   (1) 能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。

   (2) 客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。

2. 远程代理

   为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率。

3. 虚拟代理

   通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。

4. 缓冲代理

   为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。

5. 保护代理

   可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。

#### 4.7.8 代理模式缺点

(1) 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。

(2) 实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。

#### 4.7.9 适用场景

   (1) 当客户端对象需要访问远程主机中的对象时可以使用远程代理。

   (2) 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。

   (3) 当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。

   (4) 当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。

   (5) 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。

> 说实话，感觉这玩意儿很牛逼，应该需要深挖。以后有时间看一下，学到现在最牛逼的一个了，属于是。(=_=)

## 5. 十一个行为型模式

### 5.1 职责链模式

> **职责链模式(Chain of Responsibility Pattern)**：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。
>
> *猜测工作流。可以有效解决if else 过多问题*

#### 5.1.1 在职责链模式结构图中包含如下几个角色

  ● Hand**ler（抽象处理者）：**它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的successor），作为其对下家的引用。通过该引用，处理者可以连成一条链。

  ● **ConcreteHandler（具体处理者）：**它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。

**系统可以在不影响客户端的情况下动态地重新组织链和分配责任**。

> 需要注意的是：职责链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般是在使用该职责链的客户端中创建职责链。职责链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。

#### 5.1.2 实现

```java
//实体类
@Data
public class PurchaseOrder {
    private BigDecimal amount;
    private String name;
    private int number;
}

//抽象审批类
public abstract class Approver {
    protected Approver successor;
    protected String name;

    public Approver(String name) {
        this.name = name;
    }

    public void setSuccessor(Approver successor) {
        this.successor = successor;
    }

    public abstract void processRequest(PurchaseOrder purchaseOrder);
}
```

```java
//实现类
//小组长
public class GroupLeaderApprover extends Approver {
    public GroupLeaderApprover(String name) {
        super(name);
    }

    @Override
    public void processRequest(PurchaseOrder purchaseOrder) {
        if (purchaseOrder.getAmount().compareTo(new BigDecimal(1000)) < 0) {
            System.out.println(name + ":我审批了，购买金额为" + purchaseOrder.getAmount() + "购买东西：" + purchaseOrder.getName() + "数量为" + purchaseOrder.getNumber());
        } else {
            successor.processRequest(purchaseOrder);
        }
    }
}

//经理
public class ManagerApprover extends Approver {
    public ManagerApprover(String name) {
        super(name);
    }

    @Override
    public void processRequest(PurchaseOrder purchaseOrder) {
        if (purchaseOrder.getAmount().compareTo(new BigDecimal(5000)) < 0) {
            System.out.println(name + ":我审批了，购买金额为" + purchaseOrder.getAmount() + "购买东西：" + purchaseOrder.getName() + "数量为" + purchaseOrder.getNumber());
        } else {
            successor.processRequest(purchaseOrder);
        }
    }
}

//董事长
public class ChairmanApprover extends Approver {
    public ChairmanApprover(String name) {
        super(name);
    }

    @Override
    public void processRequest(PurchaseOrder purchaseOrder) {
        if (purchaseOrder.getAmount().compareTo(new BigDecimal(10000)) < 0) {
            System.out.println(name + ":我审批了，购买金额为" + purchaseOrder.getAmount() + "购买东西：" + purchaseOrder.getName() + "数量为" + purchaseOrder.getNumber());
        } else {
            successor.processRequest(purchaseOrder);
        }
    }
}

//幕后大领导
public class MaxLeaderApprover extends Approver {
    public MaxLeaderApprover(String name) {
        super(name);
    }

    @Override
    public void processRequest(PurchaseOrder purchaseOrder) {
        System.out.println(name + ":我审批了，购买金额为" + purchaseOrder.getAmount() + "购买东西：" + purchaseOrder.getName() + "数量为" + purchaseOrder.getNumber());
    }
}

//测试
public static void main(String[] args) {
    Approver groupLeader1,groupLeader2,manager1,manager2,chairman,maxLeader;
    groupLeader1 = new GroupLeaderApprover("组长1");
    groupLeader2 = new GroupLeaderApprover("组长2");
    manager1 = new ManagerApprover("经理1");
    manager2 = new ManagerApprover("经理2");
    chairman = new ChairmanApprover("总裁");
    maxLeader = new MaxLeaderApprover("最高经理");
    groupLeader1.setSuccessor(manager1);
    groupLeader2.setSuccessor(manager2);
    manager1.setSuccessor(chairman);
    manager2.setSuccessor(chairman);
    chairman.setSuccessor(maxLeader);
    PurchaseOrder purchaseOrder = new PurchaseOrder();
    purchaseOrder.setAmount(new BigDecimal(500));
    purchaseOrder.setName("苹果");
    purchaseOrder.setNumber(10);
    groupLeader1.processRequest(purchaseOrder);
    System.out.println("--------------------------------------------");
    purchaseOrder.setAmount(new BigDecimal(3000));
    groupLeader2.processRequest(purchaseOrder);
    System.out.println("--------------------------------------------");
    purchaseOrder.setAmount(new BigDecimal(6000));
    groupLeader2.processRequest(purchaseOrder);
    System.out.println("--------------------------------------------");
    purchaseOrder.setAmount(new BigDecimal(10800));
    groupLeader2.processRequest(purchaseOrder);
}
```

![image-20220629140832083](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206291408284.png)

#### 5.1.3 添加一个区域经理

```java
public class RegionalManagerApprover extends Approver {
    public RegionalManagerApprover(String name) {
        super(name);
    }

    @Override
    public void processRequest(PurchaseOrder purchaseOrder) {
        if (purchaseOrder.getAmount().compareTo(new BigDecimal(8000)) < 0) {
            System.out.println(name + ":我审批了，购买金额为" + purchaseOrder.getAmount() + "购买东西：" + purchaseOrder.getName() + "数量为" + purchaseOrder.getNumber());
        } else {
            successor.processRequest(purchaseOrder);
        }
    }
}

//只需添加实现类即可
//测试
public static void main(String[] args) {
    Approver groupLeader1,groupLeader2,manager1,manager2,chairman,maxLeader,regionalLeader;
    groupLeader1 = new GroupLeaderApprover("组长1");
    groupLeader2 = new GroupLeaderApprover("组长2");
    manager1 = new ManagerApprover("经理1");
    manager2 = new ManagerApprover("经理2");
    chairman = new ChairmanApprover("总裁");
    maxLeader = new MaxLeaderApprover("最高经理");
    regionalLeader = new RegionalManagerApprover("区域经理");
    groupLeader1.setSuccessor(manager1);
    groupLeader2.setSuccessor(manager2);
    manager1.setSuccessor(regionalLeader);
    manager2.setSuccessor(regionalLeader);
    regionalLeader.setSuccessor(chairman);
    chairman.setSuccessor(maxLeader);
    PurchaseOrder purchaseOrder = new PurchaseOrder();
    purchaseOrder.setAmount(new BigDecimal(500));
    purchaseOrder.setName("苹果");
    purchaseOrder.setNumber(10);
    groupLeader1.processRequest(purchaseOrder);
    System.out.println("--------------------------------------------");
    purchaseOrder.setAmount(new BigDecimal(3000));
    groupLeader2.processRequest(purchaseOrder);
    System.out.println("--------------------------------------------");
    purchaseOrder.setAmount(new BigDecimal(6000));
    groupLeader2.processRequest(purchaseOrder);
    System.out.println("--------------------------------------------");
    purchaseOrder.setAmount(new BigDecimal(8888));
    groupLeader2.processRequest(purchaseOrder);
    System.out.println("--------------------------------------------");
    purchaseOrder.setAmount(new BigDecimal(10800));
    groupLeader2.processRequest(purchaseOrder);
}
```

![image-20220629141410869](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206291414027.png)

#### 5.1.4 纯与不纯的职责链模式

1. 纯的职责链模式

   一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。而且在纯的职责链模式中，要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况。在前面的采购单审批实例中应用的是纯的职责链模式。

2. 不纯的职责链模式

   在一个不纯的职责链模式中允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收。

   **每一级组件在接收到事件时，都可以处理此事件，而不论此事件是否在上一级已得到处理，还存在事件未被处理的情况**。

   这种事件处理机制又叫**事件浮升(Event Bubbling)**机制。

#### 5.1.5 优缺点

1. 优点

     (1) 职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。

      (2) 请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。

      (3) 在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。

      (4) 在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的。

2. 缺点

      (1) 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。

      (2) 对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。

      (3) 如果建链不当，可能会造成循环调用，将导致系统陷入死循环。

### 5.2 命令模式

> **命令模式(Command Pattern)**：将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作**(Action)**模式或事务**(Transaction)**模式。
>
> **命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求**。

#### 5.2.1 命令模式结构图中包含如下几个角色

   ● **Command（抽象命令类）**：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。

   ● **ConcreteCommand（具体命令类）**：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方法时，将调用接收者对象的相关操作(Action)。

   ● **Invoker（调用者）**：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。

   ● **Receiver（接收者）**：接收者执行与请求相关的操作，它具体实现对请求的业务处理。

> 命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开。每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行相应的操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的。

#### 5.2.2 简单实现

```java
public interface Command {
    void execute();

   public default void setReceiver(Receiver receiver) {
       receiver.action();
   }

}

public class Invoker {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void action() {
        command.execute();
    }
}

public class Receiver {
    public void action() {
        System.out.println("执行命令");
    }
}

//实现
public class BlowUpCommand implements Command {
    @Override
    public void execute() {
        System.out.println("放大");
    }
}

public class ReSizeCommand implements Command {
    @Override
    public void execute() {
        System.out.println("恢复");
    }
}

public class ZoomOutCommand implements Command {
    @Override
    public void execute() {
        System.out.println("缩小");
    }
}

//测试
public static void main(String[] args) {
    Receiver receiver = new Receiver();
    Command command1, command2, command3;
    command1 = new ReSizeCommand();
    command2 = new BlowUpCommand();
    command3 = new ZoomOutCommand();
    command1.setReceiver(receiver);
    command2.setReceiver(receiver);
    command3.setReceiver(receiver);
    Invoker invoker = new Invoker();
    invoker.setCommand(command1);
    invoker.action();
    Invoker invoker2 = new Invoker();
    invoker2.setCommand(command2);
    invoker2.action();
    Invoker invoker3 = new Invoker();
    invoker3.setCommand(command3);
    invoker3.action();
}
```

![image-20220629152220104](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206291522261.png)

#### 5.2.3 实际问题解决

>  Sunny软件公司开发人员为公司内部OA系统开发了一个桌面版应用程序，该应用程序为用户提供了一系列自定义功能键，用户可以通过这些功能键来实现一些快捷操作。Sunny软件公司开发人员通过分析，发现不同的用户可能会有不同的使用习惯，在设置功能键的时候每个人都有自己的喜好，例如有的人喜欢将第一个功能键设置为“打开帮助文档”，有的人则喜欢将该功能键设置为“最小化至托盘”，为了让用户能够灵活地进行功能键的设置，开发人员提供了一个“功能键设置”窗口，该窗口界面如图2所示：
>
>  ![1366033417_2468](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206301011141.jpg)
>
>
>  图2  “功能键设置”界面效果图
>
>  通过如图2所示界面，用户可以将功能键和相应功能绑定在一起，还可以根据需要来修改功能键的设置，而且系统在未来可能还会增加一些新的功能或功能键。

```java
//窗口类
public class FBSettingWindow {
    private String title;
    private List<FunctionButton> functionButtonList = new ArrayList<>();

    public FBSettingWindow(String title) {
        this.title = title;
    }

    public void addFunctionButton(FunctionButton functionButton) {
        functionButtonList.add(functionButton);
    }

    public void removeFunctionButton(FunctionButton functionButton) {
        functionButtonList.remove(functionButton);
    }

    public void displayWindow(){
        System.out.println("--------------------------------------------");
        System.out.println("|显示窗口：" + title);
        System.out.println("|显示按钮：");
        for (FunctionButton functionButton : functionButtonList) {
            System.out.println("|" +functionButton.getName());
        }
        System.out.println("--------------------------------------------");
    }
}

//功能键类
public class FunctionButton {
    private String name;
    private Command command;

    public FunctionButton(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setCommand(Command command) {
        this.command = command;
    }

    public void onClick() {
        System.out.print("点击功能键:");
        command.execute();
    }
}

//命令类及实现
public interface Command {
    void execute();
}

public class ZoomInCommand implements Command {
    @Override
    public void execute() {
        System.out.println("放大");
    }
}

public class ZoomOutCommand implements Command {
    @Override
    public void execute() {
        System.out.println("缩小");
    }
}

//测试
public static void main(String[] args) {
    FBSettingWindow fbSettingWindow = new FBSettingWindow("设置");
    FunctionButton fbZoomIn = new FunctionButton("放大");
    FunctionButton fbZoomOut = new FunctionButton("缩小");
    fbSettingWindow.addFunctionButton(fbZoomIn);
    fbSettingWindow.addFunctionButton(fbZoomOut);
    Command zoomIn, zoomOut;
    zoomIn = new ZoomInCommand();
    zoomOut = new ZoomOutCommand();
    fbZoomIn.setCommand(zoomIn);
    fbZoomOut.setCommand(zoomOut);
    fbSettingWindow.displayWindow();
    fbZoomIn.onClick();
    fbZoomOut.onClick();
    fbZoomIn.setCommand(zoomOut);
    fbZoomOut.setCommand(zoomIn);
    fbZoomIn.onClick();
    fbZoomOut.onClick();
}
```

![image-20220630103401776](https://howe-pic-bed.oss-cn-beijing.aliyuncs.com/picbed/202206301034977.png)

> 可见，设置和使用按键是分开的。这里设置的时候属于是命令发送者，而每一个具体的命令实现属于命令接收者。
>
> **每一个具体命令类对应一个请求的处理者（接收者），通过向请求发送者注入不同的具体命令对象可以使得相同的发送者对应不同的接收者，从而实现“将一个请求封装为一个对象，用不同的请求对客户进行参数化”**，客户端只需要将具体命令对象作为参数注入请求发送者，无须直接操作请求的接收者。

#### 5.2.4 撤销操作的实现
